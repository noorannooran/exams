# Lecture 9
## JSP Introduction and Overview
### Why JSPS?
- it's terrible to use servlets for presentation logic

### Concept
- use regular HTML for most of page
- mark servlet code with special tags
- JSP gets trnaslated into a servlet, and servlet is what gets invoked

### Benefits
- Write/Read HTML
- Specialization
	- separation of presentation logic from internal logic
- Organizaed Code


### JSP Misunderstandings
- JSP is server-side not client-side
- JSP runs on the server

### Translation/ Request time
- at translation time JSP gets translated into servlet code
- at request time, servlet code gets executed
- page translation occurs NOT for each request but the first time it is accessed after it's modified

<hr>

# Lecture 10
## Invoking Java Code with JSP Scripting Elements

### Uses of JSP
- scripting elements call servlet code directly
- call servlet code indirectly
- Beans
- MVC
- MVC with EL
- custom JSPs-tags
- MVC with beans, custom tags, framework like JSF 2.0

### Options
1. 25 lines of java code directly in JSP
2. put the 25 lines in separate java class and 1 line in JSP page that invokes it

#### Second option better
- Development:
	- separate class in java environment
- Debugging:
	- set break points and debug
- Testing:
	- easier to test
- Reuse:
	- can reuse class for multiple pages

### Expressions
```java
<%=expression %>

//example
Current time: <%=new java.util.Date()%>
Your hostname: <%= request.getRemoteHost() %>
```
- evaluated and inserted into servlet's output


### Scriplets
```java
<% code %>
//example
<%
String bgColor = request.getParameter("bgColor");
if((bgColor == null) || bgColor.trim().equals(""))){
	bgColor = "White";
}
%>

<BODY BGCOLOR="<%= bgColor %>
```
- inserted verbatim into the servlet's _jspService method
- can use conditionals with scriptlets (if else, etc.)


### Declarations
```java
<%! code %>
//example
<%! private int someField = 5 %.
```
- inserted verbatim into the body of servlet class

### Predefined Variables
- request
- response
- out
- session
- application

<hr>

# Lecture 11
## JSP Page Directive
### Purpose
- high level information about servlet resulting from JSP
- controls:
	- which classes are imported
	- which class the servlet extends
	- what MIME type is generated
	- how multithreading is handled
	- if servlet participates in sessions
	- size and behaviour of output bugger
	- what page handles unexpected errors

### Import Attribute
```java
<%@page import ="package.class"%>
```
- generate import statements on top of servlet definition

### contentType and pageEncoding
```java
<%@page contentType="MIME-Type"%>
<%@page pageEncoding="Character-Set"%>

```
- specify the MIME type of the page generated by the servlet resulting from the JSP
- specify the character encoding in which the file is encoded in
	- attribute value cannot be computed at request time

### session, isELIgnored, buffer, errorPage, isErrorPage Attribute
```java
<%@ page session="true" %> 
//or
<%@ page session="false" %>
```
- by default, page is a part of the session
- saves memory to control this
- related pages have to do this for it to be useful

### isELIgnored
```java
<%@ page isELIgnored="true" %> 
//or
<%@ page session="false" %>
```
- is expression language ignored or evaluated normally
- servlets 2.3 or earlier : default true
- servlets 2.4 or later: default false

### buffer
```java
<%@ page buffer="sizekb" %> 
//or
<%@ page buffer="none" %>
```
- size of buffer used by out variable
- lets you set HTTP headers after some page content has been generated
- default is system specific, at least 8kb

### errorPage
```java
<%@ page errorPage="Relative URL" %> 
```
- specifies error page that processes any exceptions thrown and not caught in current page
- can specify application-wide error pages in web.xml file

### isErrorPage
```java
<%@ page isErrorPage="true" %> 
//or
<%@ page isErrorPage="false" %>
```
- whether or not page is error page for another jsp
- predefined var called **exception** is created an accessible from error pages
	- use for emerg backup only
- **explicitly** handle exceptions

<hr>

# Lecture 12
## Including files in JSP pages

### JSP lifecycle
1. web container receives a request for a JSP
	- if JSP exists as translated and has not chaned
		- web container services the request
	- if first request for JSP, or JSP has changed
		- web container translates the JSP
2. JSP file is translated into servlet like implementation class
3. servlet **compiles** creating a JSP instance
4. Service client requests
5. Eventually the instance is destroyed

### Including Pages at request time
```java
<jsp:include page="Relative Address"/>

```
- reuse JSP, HTML, plain texgt context
- permit updates to content without changing main JSPs
- **dynamic** include
- included content cannot affect the main page
- page is included at **runtime**
	- no actual content include in code

### Including Page at Translation Time
```java
<%@include file="RelativeAddress"%>

```
- reuse JSP content in multiple pages
- JSP content **affects** the main page
- **static include**
- e.g. header, footer, nav bar
- not suitable for changing resources
- included at **compile time**
	- actual code is included

### Which to Use
- use jsp:include whenever possible
	- speed difference
- static includes:
	- affect page size
	- avoid overhead of request dispatcher
- dynamic includes:
	- affect processing overhead

<hr>

# Lecture 13
## Java Beans
### Examples
```java
<jsp:getProperty... property="firstName"/>
<jsp:setProperty...property="firstName" value="..."/>

${customer.firstName}

```

### Things you can do
1. can put constraints on values with accessors
	- e.g. check values, set with a default value
2. can change internal rep. without changing interface
	- e.g. converting a value
3. arbitrary side effects
	- e.g. updating Display

### Basics
1. jsp: useBean
	- new Bean
	- id="beanName"
	- class="package.classname"
2. jsp:setProperty
	- modifies a bean property
3. jsp:getProperty
	- reads and outputs value of bean property

### General Approach
1. User submits form that refers to a jsp
2. JSP instantiates a bean
3. request data is passed to the bean
4. output values derived from request data

### Advantages
1. Easier to derive object values from request params
2. Easier to share objects among pages or servlets

### Param Attribute
- of jsp:setProperty
- value should come from a specific request parameter

```java
<jsp:setProperty
name="entry"
property="discountCode"
param="discountCode"/>
```

### Sharing beans with scope
1. Page scoped
	- unshared beans
	- only accessible within pages where they were created
2. request scope
	- sharing beans for pages processing the request
3. session scope
	- sharing beans for pages belonging to the same session
4. application scope
	- sharing beans everywhere

### Using *
```java

<jsp:setProperty name="pageBean" property="*"/>
```
- property values should come from incoming **request params**
- whose names match the bean property name

<hr>

# Lecture 14
## MVC Architecture
- combine servlets and JSPS

### Why?
- simple dynamic code:
	- call servlet code from scripting elements
- more complex:
	- custom classes called from scripting elements
- more complex:
	- beans and custom tags

### Beans: Java classes that:
- have empty constructor
- no public instance variables
- accessor methods : get and set
- must always be in packages

### Implementing MVC with RequestDispatcher
1. Identify and define beans
2. Use servlet to handle requests
3. Obtain bean instances
4. Store the bean in Request, Session, or Servlet COntext
5. Forward request to JSP
6. Extract data from the beans

```java
RequestDispatcher dispatcher =
	request.getRequestDispatcher(address);
	dispatcher.forward(request, response);
```

### Standards
- JSP should not **create** objects
	- servlet should ahndle this
- JSP should not **modify** objects
	- get NOT set property

### Scopes
- place the bean is stored
- where and how long it's visible

#### Request
- visible to the servlet
- visible to the page the servlet forwards to
- cannot be seen by other users or on other pages

```java
request.setAttribute("customer", myCustomer);

```
```jsp
${customer.firstName}
```
#### Session
- visible to servlet
- visible to page servlet forwards to
- can be seen on other pages or later if same user
- datta cannot be seen by other users
```java

HttpSession session = request.getSession();
session.setAttribute("key", value);

```

```jsp
${key.someProperty}
```
- Redirect to page instead of forwarding
- use response.SendRedirect for session

### sendRedirect
- user sees JSP URL
- two round trips to client with sendRedirect

#### Advantages
- user can visit JSP page separately
- can bookmark page

#### Disadvantages
- 2 trips = more expensive
- bean data might not be available (can visit JSP without servlet)



#### Application
- visible to all users and all pages in application
``` java

synchronized(this){
	SomeBean value = Lookup.findResult();
	getServletContext().setAttribute("key", value);

//get request dispatcher
//forward request and response
}
```
- synchronized for thread safety
```jsp
${key.someProperty}
```
- forwarding with request dispatcher is transparent to client
- original URL is only URL browser knows about

### Data Sharing Approaches
1. Session-based sharing
	- when data is only for one client
2. Applicaiton-based sharing
	- data is shared among multiple clients


### Forwarding from JSP
- new page generates all output
- original page cannot generate any output
```jsp
<jsp:forward page="<% destination %>" />
```
- don't do this

### Including pages
- output can be generated by multiple pages
- original page can generate output before and after included page
- original servlet does not see output of included page

<hr>

# Lecture 15
## JSP 2 Expression Language
### When to Use:

|Servlets Only   | JSPs Only  | MVC  |
|---|---|---|
| output is binary  | output is character data (HTML)  | single reques = different outputs  |
| there is no output  |  | large development team  |
| format/layout is **variable**  | format/layout is **fixed**   | complicated data processing, **fixed** layout   |

### Implementing MVC with RequestDispatcher
1. Id and define **bean** to represent data
2. Use servlet to handle requests
3. Obtain bean instances
4. Store bean in **Request**, **Session** or **ServletContext**
5. Forward request to jsp
6. Extract data from the beans

### Drawback of MVC
- Presentation

## Expression Language (EL)
- take difficulty out of presentation logic

```jsp
<h1>First name is ${customer.firstName}</h1>

```

### Advantages
- concise access to stored objects
```jsp
//get a scoped variable
${saleItem}

```
- Shorthand notation for bean properties
```jsp
${company.companyName}

```
- To access element of Array, List, Map:
```jsp
${variable[indexOrKey]}

```

### More advantages
- access to request params, cookies etc.
- simple operators (test empty, etc)
- conditional output 
```jsp
${test ? option1: option2}

```
- automatic type conversion
	- parsing strings as numbers
- missing values or NullPointerExceptions result in **empty strings**

### Activating EL
- Tomcat 5 or greater
- add JSP 2.x web.xml file


### Use MVC When:
- one submission = more than one result
- several pages have similar processing
- **moderate** complexity

### Approach
1. servlet answers incoming request
2. servlet calls business logic, stores result in beans
3. servlet invokes JSP via RequestDispatcher.forward
4. JSP page reads data from beans

### Dot and Array Notation
```jsp
${name.property}
//same as
${name[property]}
```

#### Reasons
1. access **arrays**, **lists**, **collections**
2. calculate property name at request time
3. use names that are illegal as Java variable names


```jsp
//can do
${first[0]}

//can't do
${first.0}
```
### Referencing Implicit Objects
1. pageContext
```jsp
${pageContext.session.id}
``
2. param and param values (Request params)
```jsp
${param.custID} 

${param['custID']}
```
3. Cookie
```jsp
${cookie.userCookie.value}
${cooke.["userCookie"].value}
```
4. pageScope, requestScope, sessionScope, applicationScope
```jsp
${sessionScope['cart']}
```

### Operators
1. Arithmetic
> + - * /  % 
2. Relational
> ==  !=  <  >  <=  >= 
3. Logical
> $$ || Not
4. Empty
> Empty
	- **true** for null, empty string, empty array, empty list, empty map
	- **false** otherwise

### Conditional Expressions
```jsp
${test ? expression1 : expression2}
```

#### Concerns
- JSTL is better for conditional testing
	- c:if / c:choose
	- tempts putting business logic in JSP
	- JSP ideally only used for presentation


<hr>

# Lecture 16
## JSF2
1. set of web-based GUI controls and handlers
2. device-independent GUI control Framework
3. MVC based web application framework

## Advantages
1. Custom GUI Controls
2. Event Handling
	- respond to buttons, changes in values, user selections
3. Managed Beans
	- simplify param processing
4. Ajax support
5. form field conversion and validation
6. page templating
7. centralize file-based configuration
	- xml/ PROPERTY FILES
8. Consistent
	- use MVC

## Disadvantages
